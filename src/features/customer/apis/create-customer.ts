/**
 * POST /api/users/customer
 * Create a new customer (B2C or B2B)
 */

import { Router, Response } from 'express';
import { RequestWithUser } from '../../../interfaces';
import { requireAuth, requirePermission, validationMiddleware } from '../../../middlewares';
import { ResponseFormatter, HttpException, logger } from '../../../utils';
import { db } from '../../../database';
import { eq, and } from 'drizzle-orm';
import { users } from '../../user/shared/user.schema';
import { customerProfiles } from '../shared/customer-profiles.schema';
import { businessCustomerProfiles } from '../shared/business-profiles.schema';
import { syncTags } from '../../tags/services/tag-sync.service';
import { notificationService } from '../../notifications/services/notification.service';
import { createCustomerSchema, CreateCustomerDto } from '../shared/validation';

// Validation Schema imported from ../shared/validation

const handler = async (req: RequestWithUser, res: Response) => {
    const data: CreateCustomerDto = req.body;

    logger.info('Creating new customer', { email: data.email });

    // Check if user already exists
    const [existingUser] = await db
        .select()
        .from(users)
        .where(eq(users.email, data.email));

    if (existingUser) {
        throw new HttpException(409, 'A customer with this email already exists');
    }

    // Check if email was verified via OTP
    const { emailOtps } = await import('../../user/shared/email-otp.schema');
    const [verifiedOtp] = await db
        .select()
        .from(emailOtps)
        .where(
            and(
                eq(emailOtps.email, data.email.toLowerCase()),
                eq(emailOtps.purpose, 'email_verification'),
            )
        )
        .limit(1);

    const isEmailVerified = verifiedOtp?.verified_at !== null;
    const emailVerifiedAt = verifiedOtp?.verified_at || null;

    // Check if secondary email was verified via OTP
    let isSecondaryEmailVerified = false;
    if (data.secondary_email) {
        const [secondaryVerifiedOtp] = await db
            .select()
            .from(emailOtps)
            .where(
                and(
                    eq(emailOtps.email, data.secondary_email.toLowerCase()),
                    eq(emailOtps.purpose, 'email_verification'),
                )
            )
            .limit(1);
        isSecondaryEmailVerified = secondaryVerifiedOtp?.verified_at !== null;
    }

    const result = await db.transaction(async (tx) => {
        // 1. Create User with email_verified status (display_id auto-generated by trigger)
        const [newUser] = await tx.insert(users)
            .values({
                first_name: data.first_name,
                middle_name: data.middle_name || null,
                last_name: data.last_name,
                email: data.email,
                display_name: data.display_name,
                phone_number: data.phone_number,
                // No user_type set (deprecated field)
                tags: data.tags || [],
                date_of_birth: data.date_of_birth || undefined,
                gender: data.gender,
                preferred_language: data.preferred_language || 'en',
                languages: data.languages || [],
                profile_image_url: data.profile_image_url,
                email_verified: isEmailVerified,
                email_verified_at: emailVerifiedAt,
                secondary_email: data.secondary_email,
                secondary_email_verified: isSecondaryEmailVerified,
                secondary_phone_number: data.secondary_phone_number,
            })
            .returning();

        // 2. Create Customer Profile (always created for customers)
        await tx.insert(customerProfiles)
            .values({
                user_id: newUser.id,
                segments: data.segments || ['new'],
                notes: data.notes,
            });

        // 3. Create Business Profile if B2B data provided
        if (data.company_legal_name || data.tax_id || data.credit_limit) {
            await tx.insert(businessCustomerProfiles)
                .values({
                    user_id: newUser.id,
                    business_type: 'sole_proprietor', // Default
                    company_legal_name: data.company_legal_name || data.first_name,
                    business_email: data.email,
                    tax_id: data.tax_id,
                    credit_limit: data.credit_limit ? String(data.credit_limit) : '0',
                    payment_terms: data.payment_terms || 'immediate',
                    notes: data.notes,
                });
        }

        return newUser;
    });

    logger.info(`Customer created successfully: ${result.id}`);

    if (data.tags && data.tags.length > 0) {
        await syncTags(data.tags, 'customer');
    }

    // Send Welcome Notification
    try {
        await notificationService.createFromTemplate(
            result.id,
            'customer_welcome',
            {
                name: result.first_name,
                email: result.email,
            },
            {
                priority: 'normal',
                actionUrl: '/profile',
                actionText: 'Go to Profile',
            }
        );
    } catch (error) {
        logger.error('Failed to send welcome notification:', error);
    }



    ResponseFormatter.success(res, result, 'Customer created successfully', 201);
};

const router = Router();

router.post(
    '/customer',
    requireAuth,
    requirePermission('users:create'),
    validationMiddleware(createCustomerSchema),
    handler
);

export default router;
