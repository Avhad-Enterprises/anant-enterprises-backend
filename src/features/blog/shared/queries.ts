import { eq, desc, inArray, sql, and } from 'drizzle-orm';
import { db } from '../../../database';
import { blogs, type NewBlog } from './blog.schema';
import { blogSubsections, type NewBlogSubsection } from './blog-subsections.schema';

/**
 * Find blog by ID with subsections
 */
export const findBlogById = async (id: string) => {
    // Fetch blog
    const result = await db.select().from(blogs).where(eq(blogs.id, id)).limit(1);
    const blog = result[0];

    if (!blog) return null;

    // Fetch subsections
    const subsections = await db
        .select()
        .from(blogSubsections)
        .where(eq(blogSubsections.blog_id, id))
        .orderBy(blogSubsections.sort_order);

    return { ...blog, subsections };
};

/**
 * Find blog by Slug with subsections
 */
export const findBlogBySlug = async (slug: string) => {
    // Fetch blog
    const result = await db.select().from(blogs).where(eq(blogs.slug, slug)).limit(1);
    const blog = result[0];

    if (!blog) return null;

    // Fetch subsections
    const subsections = await db
        .select()
        .from(blogSubsections)
        .where(eq(blogSubsections.blog_id, blog.id))
        .orderBy(blogSubsections.sort_order);

    return { ...blog, subsections };
};

/**
 * Create a new blog with optional subsections
 */
export const createBlog = async (
    blogData: NewBlog,
    subsectionsData: NewBlogSubsection[] = []
) => {
    return await db.transaction(async (tx) => {
        // 1. Create Blog
        const [newBlog] = await tx.insert(blogs).values(blogData).returning();

        // 2. Create Subsections if any
        if (subsectionsData.length > 0) {
            const subsectionsWithId = subsectionsData.map((s) => ({
                ...s,
                blog_id: newBlog.id, // Ensure correct FK
                // ID is auto-generated by default in schema, but good to ensure
            }));

            await tx.insert(blogSubsections).values(subsectionsWithId);
        }

        return newBlog;
    });
};

/**
 * Update blog and manage subsections
 */
export const updateBlog = async (
    id: string,
    blogUpdates: Partial<NewBlog>,
    subsectionsUpdates?: {
        create?: NewBlogSubsection[];
        update?: (Partial<NewBlogSubsection> & { id: string })[];
        delete?: string[]; // IDs to delete
    }
) => {
    return await db.transaction(async (tx) => {
        // 1. Update Blog
        let updatedBlog = null;
        if (Object.keys(blogUpdates).length > 0) {
            const [result] = await tx
                .update(blogs)
                .set({ ...blogUpdates, updated_at: new Date() }) // Always update timestamp
                .where(eq(blogs.id, id))
                .returning();
            updatedBlog = result;
        }

        // 2. Handle Subsections
        if (subsectionsUpdates) {
            // Create
            if (subsectionsUpdates.create && subsectionsUpdates.create.length > 0) {
                const toCreate = subsectionsUpdates.create.map((s) => ({
                    ...s,
                    blog_id: id,
                }));
                await tx.insert(blogSubsections).values(toCreate);
            }

            // Update
            if (subsectionsUpdates.update && subsectionsUpdates.update.length > 0) {
                for (const sub of subsectionsUpdates.update) {
                    const { id: subId, ...data } = sub;
                    if (Object.keys(data).length > 0) {
                        await tx
                            .update(blogSubsections)
                            .set(data)
                            .where(and(eq(blogSubsections.id, subId), eq(blogSubsections.blog_id, id)));
                    }
                }
            }

            // Delete
            if (subsectionsUpdates.delete && subsectionsUpdates.delete.length > 0) {
                await tx
                    .delete(blogSubsections)
                    .where(
                        and(
                            eq(blogSubsections.blog_id, id),
                            inArray(blogSubsections.id, subsectionsUpdates.delete)
                        )
                    );
            }
        }

        return updatedBlog || (await findBlogById(id));
    });
};

/**
 * Delete blog (and cascade subsections)
 */
export const deleteBlog = async (id: string) => {
    const [deletedBlog] = await db
        .delete(blogs)
        .where(eq(blogs.id, id))
        .returning();
    return deletedBlog;
};

/**
 * Bulk delete blogs
 */
export const bulkDeleteBlogs = async (ids: string[]) => {
    if (ids.length === 0) return [];
    return await db.delete(blogs).where(inArray(blogs.id, ids)).returning();
};

/**
 * Get all blogs with filters and pagination
 */
export const getAllBlogs = async (
    page: number = 1,
    limit: number = 10,
    filters: {
        status?: string | null;
        category?: string | null;
        search?: string | null;
    } = {}
) => {
    const offset = (page - 1) * limit;

    // Build conditions
    const conditions = [];

    if (filters.status) {
        conditions.push(eq(blogs.status, filters.status as any));
    }

    if (filters.category) {
        conditions.push(eq(blogs.category, filters.category));
    }

    if (filters.search) {
        const searchPattern = `%${filters.search}%`;
        conditions.push(
            sql`(${blogs.title} ILIKE ${searchPattern} OR ${blogs.description} ILIKE ${searchPattern})`
        );
    }

    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;

    // Count total
    const [countResult] = await db
        .select({ total: sql<number>`count(*)` })
        .from(blogs)
        .where(whereClause);

    const total = Number(countResult?.total || 0);

    // Fetch data
    const data = await db
        .select()
        .from(blogs)
        .where(whereClause)
        .limit(limit)
        .offset(offset)
        .orderBy(desc(blogs.created_at));

    return {
        data,
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
    };
};
