import { eq, desc, asc, inArray, sql, and, gte, lte } from 'drizzle-orm';
import { db } from '../../../database';
import { blogs, type NewBlog } from './blog.schema';
import { blogSubsections, type NewBlogSubsection } from './blog-subsections.schema';

/**
 * Find blog by ID with subsections
 */
export const findBlogById = async (id: string) => {
    // Fetch blog
    const result = await db.select().from(blogs).where(and(eq(blogs.id, id), eq(blogs.is_deleted, false))).limit(1);
    const blog = result[0];

    if (!blog) return null;

    // Fetch subsections
    const subsections = await db
        .select()
        .from(blogSubsections)
        .where(eq(blogSubsections.blog_id, id))
        .orderBy(blogSubsections.sort_order);

    return { ...blog, subsections };
};

/**
 * Find blog by Slug with subsections
 */
export const findBlogBySlug = async (slug: string) => {
    // Fetch blog
    const result = await db.select().from(blogs).where(and(eq(blogs.slug, slug), eq(blogs.is_deleted, false))).limit(1);
    const blog = result[0];

    if (!blog) return null;

    // Fetch subsections
    const subsections = await db
        .select()
        .from(blogSubsections)
        .where(eq(blogSubsections.blog_id, blog.id))
        .orderBy(blogSubsections.sort_order);

    return { ...blog, subsections };
};

/**
 * Create a new blog with optional subsections
 */
export const createBlog = async (
    blogData: NewBlog,
    subsectionsData: NewBlogSubsection[] = []
) => {
    return await db.transaction(async (tx) => {
        // 1. Create Blog
        const [newBlog] = await tx.insert(blogs).values(blogData).returning();

        // 2. Create Subsections if any
        if (subsectionsData.length > 0) {
            const subsectionsWithId = subsectionsData.map((s) => ({
                ...s,
                blog_id: newBlog.id, // Ensure correct FK
                // ID is auto-generated by default in schema, but good to ensure
            }));

            await tx.insert(blogSubsections).values(subsectionsWithId);
        }

        return newBlog;
    });
};

/**
 * Update blog and manage subsections
 */
export const updateBlog = async (
    id: string,
    blogUpdates: Partial<NewBlog>,
    subsectionsUpdates?: {
        create?: NewBlogSubsection[];
        update?: (Partial<NewBlogSubsection> & { id: string })[];
        delete?: string[]; // IDs to delete
    }
) => {
    return await db.transaction(async (tx) => {
        // 1. Update Blog
        let updatedBlog = null;
        if (Object.keys(blogUpdates).length > 0) {
            const [result] = await tx
                .update(blogs)
                .set({ ...blogUpdates, updated_at: new Date() }) // Always update timestamp
                .where(eq(blogs.id, id))
                .returning();
            updatedBlog = result;
        }

        // 2. Handle Subsections
        if (subsectionsUpdates) {
            // Create
            if (subsectionsUpdates.create && subsectionsUpdates.create.length > 0) {
                const toCreate = subsectionsUpdates.create.map((s) => ({
                    ...s,
                    blog_id: id,
                }));
                await tx.insert(blogSubsections).values(toCreate);
            }

            // Update
            if (subsectionsUpdates.update && subsectionsUpdates.update.length > 0) {
                for (const sub of subsectionsUpdates.update) {
                    const { id: subId, ...data } = sub;
                    if (Object.keys(data).length > 0) {
                        await tx
                            .update(blogSubsections)
                            .set(data)
                            .where(and(eq(blogSubsections.id, subId), eq(blogSubsections.blog_id, id)));
                    }
                }
            }

            // Delete
            if (subsectionsUpdates.delete && subsectionsUpdates.delete.length > 0) {
                await tx
                    .delete(blogSubsections)
                    .where(
                        and(
                            eq(blogSubsections.blog_id, id),
                            inArray(blogSubsections.id, subsectionsUpdates.delete)
                        )
                    );
            }
        }

        return updatedBlog || (await findBlogById(id));
    });
};

/**
 * Delete blog (and cascade subsections)
 */
export const deleteBlog = async (id: string) => {
    const [deletedBlog] = await db
        .update(blogs)
        .set({
            is_deleted: true,
            updated_at: new Date(),
        })
        .where(eq(blogs.id, id))
        .returning();
    return deletedBlog;
};

/**
 * Bulk delete blogs
 */
export const bulkDeleteBlogs = async (ids: string[]) => {
    if (ids.length === 0) return [];
    return await db
        .update(blogs)
        .set({
            is_deleted: true,
            updated_at: new Date(),
        })
        .where(inArray(blogs.id, ids))
        .returning();
};

/**
 * Get all blogs with filters and pagination
 */
export const getAllBlogs = async (
    page: number = 1,
    limit: number = 10,
    filters: {
        status?: string | null;
        category?: string | null;
        author?: string | null;
        tags?: string | null;
        startDate?: string | null;
        endDate?: string | null;
        minViews?: number | null;
        maxViews?: number | null;
        search?: string | null;
        sortBy?: string | null;
        sortOrder?: 'asc' | 'desc' | null;
    } = {}
) => {
    const offset = (page - 1) * limit;

    // Build conditions
    const conditions = [eq(blogs.is_deleted, false)];

    if (filters.status) {
        const statuses = filters.status.split(',').map(s => s.trim());
        if (statuses.length > 1) {
            conditions.push(inArray(blogs.status, statuses as any[]));
        } else {
            conditions.push(eq(blogs.status, statuses[0] as any));
        }
    }

    if (filters.category) {
        conditions.push(eq(blogs.category, filters.category));
    }

    if (filters.author) {
        conditions.push(sql`${blogs.author} ILIKE ${`%${filters.author}%`}`);
    }

    if (filters.tags) {
        // Multi-select tags: check if ANY of the selected tags exist in the blog's tags
        // Using Postgres ?| operator (exists any)
        const tagsList = filters.tags.split(',').map(t => t.trim());
        // We need to cast the string array to text[] for the ?| operator
        conditions.push(sql`${blogs.tags} ?| array[${sql.join(tagsList.map(t => t), sql`, `)}]`);
    }

    if (filters.startDate) {
        conditions.push(gte(blogs.created_at, new Date(filters.startDate)));
    }

    if (filters.endDate) {
        // Set end date to end of day? Or just exact timestamp match?
        // Usually endDate implies end of that day.
        const end = new Date(filters.endDate);
        end.setHours(23, 59, 59, 999);
        conditions.push(lte(blogs.created_at, end));
    }

    if (filters.minViews !== undefined && filters.minViews !== null) {
        conditions.push(gte(blogs.views_count, filters.minViews));
    }

    if (filters.maxViews !== undefined && filters.maxViews !== null) {
        conditions.push(lte(blogs.views_count, filters.maxViews));
    }

    if (filters.search) {
        const searchPattern = `%${filters.search}%`;
        conditions.push(
            sql`(${blogs.title} ILIKE ${searchPattern} OR ${blogs.description} ILIKE ${searchPattern})`
        );
    }

    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;

    // Count total
    const [countResult] = await db
        .select({ total: sql<number>`count(*)` })
        .from(blogs)
        .where(whereClause);

    const total = Number(countResult?.total || 0);

    // Sorting
    let orderByClause = desc(blogs.created_at);
    if (filters.sortBy) {
        const order = filters.sortOrder === 'asc' ? asc : desc;
        switch (filters.sortBy) {
            case 'views':
            case 'views_count':
                orderByClause = order(blogs.views_count);
                break;
            case 'title':
                orderByClause = order(blogs.title);
                break;
            case 'published_at':
                orderByClause = order(blogs.published_at);
                break;
            case 'created_at':
            case 'newest':
                orderByClause = order(blogs.created_at);
                break;
            // Add legacy/other keys if needed
            case 'status':
            case 'visibility':
                orderByClause = order(blogs.status);
                break;
            case 'description':
                orderByClause = order(blogs.description);
                break;
            case 'author':
                orderByClause = order(blogs.author);
                break;
            case 'tags':
                orderByClause = order(sql`${blogs.tags}::text`);
                break;
        }
    }

    // Fetch data
    const data = await db
        .select()
        .from(blogs)
        .where(whereClause)
        .limit(limit)
        .offset(offset)
        .orderBy(orderByClause);

    return {
        data,
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
    };
};
